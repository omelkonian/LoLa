\documentclass[]{article}
\usepackage[a4paper]{geometry}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{proof}
\usepackage{color}
%\usepackage{minted}
%\usemintedstyle{friendly}

\newcommand{\W}[1]{\textsf{#1}}
\newcommand{\Wv}[1]{\mathbf{#1}}
\newcommand{\bs}{\backslash}
\newcommand{\arr}[2]{#1\longrightarrow #2}
\newcommand{\xrighta}{\alpha_{\diamond}^{r}}
\newcommand{\xrightc}{\sigma_{\diamond}^{r}}
\newcommand{\Xrighta}{\widehat{\alpha}_{\diamond}^{r}}
\newcommand{\Xrightc}{\widehat{\sigma}_{\diamond}^{r}}
\newcommand{\ld}{\triangleleft ^{-1}}
\newcommand{\rd}{\triangleright ^{-1}}
\newcommand{\dd}{\triangledown ^{-1}}
\newcommand{\F}[1]{\lceil #1 \rceil}
\newcommand{\Arrow}[1]{\xlongrightarrow{\displaystyle #1}}

\usepackage{tikz}
\usetikzlibrary{calc,shapes,arrows,positioning}
\newcommand{\tikzmark}[1]{\tikz[overlay,remember picture] \node (#1) {};}
\tikzset{string/.style = {-,semithick}}
\newcommand{\tmark}[2]{\underset{\tikzmark{#2}}{\Wv{#1}}}

\title{\textbf{Logic and Language: Exercise (Week 6)}}
\author{Orestis Melkonian [6176208], Konstantinos Kogkalidis [6230067]}
\date{}

\begin{document}
\maketitle
\section{Syntax}
\subsection{}
First, we define the rules of \textit{rightward extraction} $\Xrighta$, $\Xrightc$:
\begin{enumerate}
\begin{minipage}{0.4\textwidth}
\item[]
\[
\infer[]{\Xrighta f: (A \otimes B) \otimes \Diamond C \rightarrow D}{f: A \otimes (B \otimes \Diamond C) \rightarrow D}
\]
\end{minipage}
\begin{minipage}{0.6\textwidth}
\item[]
\[
\infer[]{\Xrightc f: (A \otimes B) \otimes \Diamond C \rightarrow D}{f: (A \otimes \Diamond C) \otimes B \rightarrow D}
\]
\end{minipage}
\end{enumerate}
We can now proceed with the derivation of
\[\mbox{$n \otimes ((n \bs n)/(s/ \Diamond \Box np)) \otimes ((np / n) \otimes n) \otimes ((np \bs s) / np)) \rightarrow n$}\] as follows:
\[
\infer[\ld]{n \otimes ((n\bs n)/(s / \Diamond \Box np) \otimes (((np/n) \otimes n) \otimes (np \bs s)/np)) \vdash n}{
	\infer[\rd]{(n\bs n)/(s / \Diamond \Box np) \otimes (((np/n) \otimes (np \bs s)/np) \vdash n \bs n}{
		\infer[/]{(n \bs n)/(s/ \Diamond \Box np) \vdash (n \bs n)/(((np / n) \otimes n) \otimes (np \bs s)/np)}{
			\infer[\bs]{n \bs n \vdash n \bs n}{
				\infer[1_n]{n \vdash n}{}
				&
				\infer[1_n]{n \vdash n}{}
			}
			&
			\infer[\rhd]{((np / n) \otimes n) \otimes ((np \bs s)/np) \vdash s/ \Diamond \Box np}{
				\infer[\Xrighta]{(((np / n) \otimes n) \otimes ((np \bs s)/np)) \otimes \Diamond \Box np \vdash s}{
					\infer[\ld]{((np / n) \otimes n) \otimes ((np \bs s)/np \otimes \Diamond \Box np) \vdash s}{
						\infer[\rd]{(np \bs s)/np \otimes \Diamond \Box np \vdash ((np / n) \otimes n) \bs s}{\
							\infer[/]{(np \bs s)/np \vdash (((np / n) \otimes n) \bs s)/ \Diamond \Box np}{
								\infer[\bs]{np \bs  s \vdash ((np / n) \otimes n)\bs s}{
									\infer[\rd]{(np / n) \otimes n \vdash np}{
										\infer[/]{np / n \vdash np / n}{
											\infer[1_{np}]{np \vdash np}{}
											&
											\infer[1_{n}]{n \vdash n}{}
										}
									}
									&
									\infer[1_s]{s \vdash s}{}
								}
								&
								\infer[\dd]{\Diamond \Box np \vdash np}{
									\infer[\Box]{\Box np \vdash \Box np}{
										\infer[1_{np}]{np \vdash np}{}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
\]

\section{Interpretation}
\subsection{}
We start by assigning a temporary variable at each rule application in the proof tree:
\[
\infer[\ld]{{\color{red}q}:n \otimes ((n\bs n)/(s / \Diamond \Box np) \otimes (((np/n) \otimes n) \otimes (np \bs s)/np)) \vdash n}{
	\infer[\rd]{{\color{red}p}:(n\bs n)/(s / \Diamond \Box np) \otimes (((np/n) \otimes (np \bs s)/np) \vdash n \bs n}{
		\infer[/]{{\color{red}o}:(n \bs n)/(s/ \Diamond \Box np) \vdash (n \bs n)/(((np / n) \otimes n) \otimes (np \bs s)/np)}{
			\infer[\bs]{{\color{red}m}:n \bs n \vdash n \bs n}{
				\infer[1_n]{n \vdash n}{}
				&
				\infer[1_n]{n \vdash n}{}
			}
			&
			\infer[\rhd]{{\color{red}n}:((np / n) \otimes n) \otimes ((np \bs s)/np) \vdash s/ \Diamond \Box np}{
				\infer[\Xrighta]{{\color{red}l}:(((np / n) \otimes n) \otimes ((np \bs s)/np)) \otimes \Diamond \Box np \vdash s}{
					\infer[\ld]{{\color{red}k}:((np / n) \otimes n) \otimes ((np \bs s)/np \otimes \Diamond \Box np) \vdash s}{
						\infer[\rd]{{\color{red}j}:(np \bs s)/np \otimes \Diamond \Box np \vdash ((np / n) \otimes n) \bs s}{\
							\infer[/]{{\color{red}i}:(np \bs s)/np \vdash (((np / n) \otimes n) \bs s)/ \Diamond \Box np}{
								\infer[\bs]{{\color{red}h}:np \bs  s \vdash ((np / n) \otimes n)\bs s}{
									\infer[\rd]{{\color{red}g}:(np / n) \otimes n \vdash np}{
										\infer[/]{{\color{red}f}: np / n \vdash np / n}{
											\infer[1_{np}]{np \vdash np}{}
											&
											\infer[1_{n}]{n \vdash n}{}
										}
									}
									&
									\infer[1_s]{s \vdash s}{}
								}
								&
								\infer[\dd]{{\color{red}d}: \Diamond \Box np \vdash np}{
									\infer[\Box]{{\color{red}b}: \Box np \vdash \Box np}{
										\infer[1_{np}]{np \vdash np}{}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
\]
We now work our way top-down through the proof-tree, writing the interpretation of each formula using the rules of 3.1.\\
\begin{align}
f &: (1_{np} \otimes \eta_n \otimes 1_n) \circ (1_{np \otimes n} \otimes 1_n \otimes 1_n) \circ (1_{np \otimes n} \otimes \epsilon_n)\\
g \equiv \rd f &: (f \otimes 1_n) \circ (1_{np} \otimes \epsilon_n)\\
h &: (1_{np} \otimes \eta_{(np/n) \otimes n} \otimes 1_s) \circ (1_{np} \otimes g \otimes 1_{((np/n) \otimes n) \otimes s}) \circ (\epsilon_{np} \otimes 1_{((np/n) \otimes n) \otimes s})\\
i &: (h \otimes \eta_{np} \otimes 1_{np}) \circ (1_{((np/n)\otimes n) \bs s) \otimes s)} \otimes d \otimes 1_{np}) \otimes (1_{((np/n) \otimes n) \bs s) \otimes s} \otimes \epsilon_{s})\\
j \equiv \rd i &: (i \otimes 1_{\Diamond \Box np}) \circ (1_{((np/n) \otimes n) \bs s} \otimes \epsilon_{\Diamond \Box np})\\
k \equiv \ld i &: (1_{(np/n) \otimes n} \otimes i) \circ (\epsilon_{(np/n) \otimes n} \otimes 1_{s})\\
l \equiv \Xrighta{k} &: \alpha \circ k\\
m &: (1_{n} \otimes \eta_{n} \otimes 1_{n}) \circ (1_{n} \otimes 1_{n} \otimes 1_{n \otimes n}) \circ (\epsilon_{n} \otimes 1_{n \otimes n})\\
n \equiv \rhd l &: (1_{(np/n) \otimes n} \otimes \eta_{(np \bs s)/np}) \circ (l \otimes 1_{(np \bs s)/np})\\
o &: (m \otimes \eta_{(((np/n) \otimes n) \otimes (np \bs s)/np)} \otimes 1_{(s/\Diamond \Box np)}) \circ (1_{ (n \bs n) \otimes (((np/n) \otimes n) \otimes (np \bs s)/np)} \otimes n \otimes 1_{s/\Diamond \Box np}) \circ (1_{ (n \bs n) \otimes (((np/n) \otimes n) \otimes (np \bs s)/np)} \otimes \epsilon_{s/\Diamond \Box np}) \notag \\
\end{align}
\\
Recursively unwrapping the above interpretations, we obtain the final interpretation:
\subsection{}
By working our way from the leaves of the proof tree, we get the following generalized Kronecker delta:
\begin{align*}
& \Wv{island}_{i}\otimes\Wv{that}_{j,k,l,m}\otimes\Wv{the}_{n,o}\otimes\Wv{hurricane}_{p}\otimes\Wv{destroyed}_{q,r,s}
\overset{\delta^{i,k,l,m,n,o}_{j,t,r,s,q,p}}{\xrightarrow{\hspace*{1cm}}}
\Wv{v}_r^{obj} \in \textsc{N} \\
\Wv{v}_r^{obj} = & \Wv{island}_{i}\otimes\Wv{that}_{i,j,k,l}\otimes\Wv{the}_{m,n}\otimes\Wv{hurricane}_{n}\otimes\Wv{destroyed}_{m,k,l} \quad \text{(relabeled)} 
\end{align*}

We give the matching diagram in the figure below:
\begin{equation*}
\tmark{N}{i} \quad \tmark{N}{i'} \otimes \tmark{N}{j} \otimes \tmark{S}{k} \otimes \tmark{N}{l} \quad \tmark{N}{m} \otimes \tmark{N}{n} \quad \tmark{N}{n'} \quad \tmark{N}{m'} \otimes \tmark{S}{k'} \otimes \tmark{N}{l'}
\begin{tikzpicture}[overlay,remember picture]
    \draw[string] (i.north) to [bend right=60] node[below] {i} (i'.north);
    \draw[string] (k.north) to [bend right=90] node[below] {k} (k'.north);
    \draw[string] (l.north) to [bend right=90] node[below] {l} (l'.north);
    \draw[string] (m.north) to [bend right=60] node[below] {m} (m'.north);
    \draw[string] (n.north) to [bend right=60] node[below] {n} (n'.north);
	\draw[string] (j.north) to node[right] {j} +(0, -1.6cm);
\end{tikzpicture}
\end{equation*}
\\
\subsection{}
In order to calculate the semantic value for the relative clause body 'the hurricane destroyed', we first apply $\Wv{the}_{MN}$ to $\Wv{hurricane}_{N}$. The operation yields the noun-phrase $\Wv{the\ hurricane}_M$, represented by a row-vector equal to that of $\Wv{hurricane}$. The verb $\Wv{destroyed}_{MKL}$ is then applied to the resulting vector, thereupon we obtain the final result $\Wv{the\ hurricane\ destroyed}_{KL}$.\\
Concretely, $\Wv{the\ hurricane\ destroyed}_{KL} = \Wv{destroyed}_{MKL}(\Wv{the}_{MN}\Wv{hurricane}_{N})$ is a 2 by 3 matrix, the elements of which are:
\[
\left(\begin{array}{ccc}
12 & -19 & 3 \\
5 & 10 & 1 \\
\end{array}
\right)
\]
given by:
\begin{equation*}
\Wv{the\ hurricane\ destroyed}(k, l) = \sum_{m \epsilon M}^{} \Wv{hurricane}(m) \times \Wv{destroyed}(m,k, l),\ \forall\ k\ \epsilon\ K,\ l\ \epsilon\ L\
\end{equation*}
The corresponding Python code is given below:
%\begin{minted}[frame=lines,baselinestretch=1.3]{python}
%import numpy as np
%hurricane, island = np.array([3,-5,5]), np.array([-5,4,0])
%the = np.eye(3)
%destroyed = np.array([[[4,-3,1],[5,5,2]], [[-1,-2,2],[2,-3,0]], [[-1,-4,2],[0,-4,-1]]])
%the_hurricane = np.matmul(the, hurricane)  # == hurricane
%the_hurricane_destroyed = np.tensordot(the_hurricane, destroyed, axes=1)
%\end{minted}

\subsection{}
The interpreted type for the relative pronoun is:
\[ \F{(n\bs n)/(s/\Diamond\Box np)} = \F{n\bs n} \otimes \F{s/\Diamond\Box np} = 
\F{n} \otimes \F{n} \otimes \F{s} \otimes \F{\Diamond\Box np} =
N \otimes N \otimes S \otimes N \]
We can now give the following Frobenius recipe for $\Wv{that}$:
\[ I \cong I \otimes I \overset{\eta_N \otimes \eta_N}{\xrightarrow{\hspace*{1cm}}} N \otimes N \otimes N \otimes N \cong N \otimes N \otimes N \otimes I \otimes N \overset{1_N \otimes \mu_N \otimes \zeta_S \otimes 1_N}{\xrightarrow{\hspace*{2cm}}} N \otimes N \otimes S \otimes N \] 
In order to obtain the final interpretation, we do the following (dictated from the above recipe):
\begin{enumerate}
\item Reduce the rank of the transitive verb by summing over the S component, thus obtaining the following matrix:
\[
\Wv{collapsed\_destroyed} =
\left(\begin{array}{ccc}
\left(\begin{array}{rrr}\textcolor{white}{-}9 & \textcolor{white}{-}2 & 3 \end{array}\right)\\[2ex]
\left(\begin{array}{rrr}\textcolor{white}{-}1 & -5 & 2 \end{array}\right)\\[2ex]
\left(\begin{array}{rrr}-1 & -8 & 1 \end{array}\right)\\[2ex]
\end{array}
\right)
\]
\item Apply $\Wv{collapsed\_destroyed}$ to $\Wv{the\_hurricane}$ in subject position:
\[
\Wv{the\_hurricane\_destroyed} =
\left(\begin{array}{ccc} 17 & -9 & 4 \end{array}\right)
\]
\item Multiply $\Wv{the\_hurricane\_destroyed}$ element-wise with $\Wv{island}$:
\[
\Wv{island\_that\_the\_hurricane\_destroyed} =
\left(\begin{array}{ccc} -85 & -36 & 0 \end{array}\right)
\]
\end{enumerate}
The corresponding Python code is given below:
%\begin{minted}[frame=lines,baselinestretch=1.3]{python}
%import numpy as np
%hurricane, island = np.array([3,-5,5]), np.array([-5,4,0])
%destroyed = np.array([[[4,-3,1],[5,5,2]], [[-1,-2,2],[2,-3,0]], [[-1,-4,2],[0,-4,-1]]])
%the = np.eye(3)
%the_hurricane = np.matmul(the, hurricane)  # == hurricane
%collapsed_destroyed = np.sum(destroyed, axis=1) # sum over the S dimension
%the_hurricane_destroyed = np.matmul(hurricane, collapsed_destroyed)
%island_that_the_hurricane_destroyed = island * hurricane_destroyed # element-wise
%\end{minted}
\end{document}